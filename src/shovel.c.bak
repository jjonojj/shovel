// the shovel language interpreter.

#include <stdio.h>
#include <stdlib.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define DELIMITERS " \t\n(){}\";"

// defs

// types

typedef enum e_type {
    TYPE_UNDEFINED = -1,

    // actual types
    TYPE_VOID,
    TYPE_STR,
    TYPE_INT,
    // ---

    TYPE_SIZE
} e_type;
const char* a_type_names[] = { "void", "str", "int" };

typedef enum e_tok {
    TOK_UNDEFINED = -1,

    TOK_TYPE,
    TOK_RET,
    TOK_LPAREN,
    TOK_RPAREN,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_EQ,
    TOK_SEMICOLON
} e_tok;

// utility functions, not really for this special use-case

int map(const char** source, const char* query, unsigned int size) {
    for (int i = 0; i < size; i++) {
        if (strcmp(query, source[i]) == 0) {
            return i;  // Return the index where the string was found
        }
    }
    return -1;  // Return -1 if the string is not found
}

// functions for the interpreter, some of them are just use-case-specific wrappers for the above functions

e_type get_type(const char* token) {
    return map(a_type_names, token, TYPE_SIZE);
}

e_tok get_tok(const char* token) {
    if (get_type(token) != TYPE_UNDEFINED) return TOK_TYPE;
    if (strcmp(token, "return") == 0) return TOK_RET;
    if (strcmp(token, "(") == 0) return TOK_LPAREN;
    if (strcmp(token, ")") == 0) return TOK_RPAREN;
    if (strcmp(token, "{") == 0) return TOK_LBRACE;
    if (strcmp(token, "}") == 0) return TOK_RBRACE;
    if (strcmp(token, "=") == 0) return TOK_EQ;
    if (strcmp(token, ";") == 0) return TOK_SEMICOLON;

    else {
        return TOK_UNDEFINED;
    }
}

void tokenize(const char *input, char ***tokens, int *num_tokens) {   
    size_t buffer_size = 10;
    size_t token_count = 0;

    *tokens = (char **)malloc(buffer_size * sizeof(char *));
    if (*tokens == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    const char *start = input;
    const char *end = NULL;
    while (*start) { 
        while (isspace((unsigned char)*start)) {
            start++;
        }
        
        if (*start == '\0') break;
    
        if (strchr(DELIMITERS, *start)) {
            
            end = start + 1;
            size_t length = 1;
            char *token = (char *)malloc(length + 1);
            if (token == NULL) {
                perror("Failed to allocate memory");
                exit(EXIT_FAILURE);
            }
            strncpy(token, start, length);
            token[length] = '\0';
            
            if (token_count >= buffer_size) {
                buffer_size *= 2;
                *tokens = (char **)realloc(*tokens, buffer_size * sizeof(char *));
                if (*tokens == NULL) {
                    perror("Failed to reallocate memory");
                    exit(EXIT_FAILURE);
                }
            }
            (*tokens)[token_count++] = token;

            start = end;
        } else {
            
            end = strpbrk(start, DELIMITERS);
            if (end == NULL) end = start + strlen(start);

            size_t length = end - start;
            char *token = (char *)malloc(length + 1);
            if (token == NULL) {
                perror("Failed to allocate memory");
                exit(EXIT_FAILURE);
            }
            strncpy(token, start, length);
            token[length] = '\0';
            
            if (token_count >= buffer_size) {
                buffer_size *= 2;
                *tokens = (char **)realloc(*tokens, buffer_size * sizeof(char *));
                if (*tokens == NULL) {
                    perror("Failed to reallocate memory");
                    exit(EXIT_FAILURE);
                }
            }
            (*tokens)[token_count++] = token;

            start = end;
        }
    }

    *tokens = (char**)realloc(*tokens, (token_count + 1) * sizeof(char*));
    (*tokens)[token_count] = NULL;
    *num_tokens = token_count;
}



void run(char** tokens, int num_tokens) {
    int index = 0;
    switch (get_tok(tokens[index])) {
        case TOK_TYPE: 
            return;
        default:
            return;
    }
}

char* read_file(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        printf("could not open file %s\n", filename);
        exit(1);
    }

    fseek(file, 0, SEEK_END);
    long length = ftell(file);
    fseek(file, 0, SEEK_SET);

    char* buffer = malloc(length + 1);
    fread(buffer, 1, length, file);
    buffer[length] = '\0';
    
    fclose(file);
    return buffer;
}

int main(int argc, char** argv) {    
    if (argc < 2) {
        printf("argc < 2, exiting.\n");
        return 1;
    }
    const char* code = read_file(argv[1]);

    char** tokens = NULL;
    int num_tokens = 0;

    tokenize(code, &tokens, &num_tokens);

    for (int i = 0; i < num_tokens; i++) {
        printf("[%s]\n", tokens[i]);
    }

    //run(tokens, num_tokens);

    free(tokens); 

    return 0;
}
